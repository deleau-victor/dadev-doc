---
sidebar_position: 1
title: 'Type de données et opérateurs en C#'
---

## Les types de valeurs

### Les types numériques intégraux

| **Type C# / Mot clé** | **Plage**                                              | **Taille**              | **Type .NET**  |
| --------------------- | ------------------------------------------------------ | ----------------------- | -------------- |
| `sbyte`               | -128 à 127                                             | 8 bits signé            | System.SByte   |
| `byte`                | 0 à 255                                                | 8 bits non signé        | System.Byte    |
| `short`               | -32 768 à 32 767                                       | 16 bits signé           | System.Int16   |
| `ushort`              | 0 à 65 535                                             | 16 bits non signé       | System.UInt16  |
| `int`                 | -2 147 483 648 à 2 147 483 647                         | 32 bits signé           | System.Int32   |
| `uint`                | 0 à 4 294 967 295                                      | 32 bits non signé       | System.UInt32  |
| `long`                | -9 223 372 036 854 775 808 à 9 223 372 036 854 775 807 | 64 bits signé           | System.Int64   |
| `ulong`               | 0 à 18 446 744 073 709 551 615                         | 64 bits non signé       | System.UInt64  |
| `nint`                | Dépend du système (calculé au moment du runtime)       | 32 ou 64 bits signé     | System.IntPtr  |
| `nuint`               | Dépend du système (calculé au moment du runtime)       | 32 ou 64 bits non signé | System.UIntPtr |

Les types nint et nuinit sont des entiers de taille native. Il s'agit d'entiers 32 bits lors de l'éxécution dans un processus 32 bits et d'entiers 64 bits lors de l'éxécution dans un processus 64 bits.

Chaque type intégral possède une propriété `MinValue` et `MaxValue` qui permettent de connaître la valeur minimale et maximale du type.

```cs
Console.WriteLine($"Valeur minimale de sbyte : {sbyte.MinValue}");
Console.WriteLine($"Valeur maximale de sbyte : {sbyte.MaxValue}");
```

#### Littéraux d'entiers

Il est possible de spécifier la base d'un littéral d'entier en utilisant un préfixe.

Les littéraux d'entiers peuvent être de type :

- _decimal_ : sans préfixe
- _héxadécimal_ : avec un préfixe `0x` ou `0X`
- _binaire_ : avec un préfixe `0b` ou `0B`

Le code suivant illustre l'utilisation de ces préfixes :

```cs
var decimalLiteral = 42;
var hexa = 0x2A; // 42 en hexadécimal
var binary = 0b101010; // 42 en binaire
```

### Les types numériques à virgule flottante

| **Type C# / Mot clé** | **Plage approximative**                            | **Précision**   | **Taille**           | **Type .NET**  |
| --------------------- | -------------------------------------------------- | --------------- | -------------------- | -------------- |
| `float`               | ±1.5 x 10<sup>-45</sup> à ±3.4 x 10<sup>38</sup>   | ~6-9 chiffres   | 32 bits (4 octets)   | System.Single  |
| `double`              | ±5.0 x 10<sup>-324</sup> à ±1.7 x 10<sup>308</sup> | ~15-17 chiffres | 64 bits (8 octets)   | System.Double  |
| `decimal`             | ±1.0 x 10<sup>-28</sup> à ±7.9 x 10<sup>28</sup>   | 28-29 chiffres  | 128 bits (16 octets) | System.Decimal |

#### Littéraux réels

Il est possible de spécifier la base d'un littéral réel en utilisant un suffixe.
IL est d'ailleurs possible d'utiliser un séparateur de chiffre avec les types numériques (entégraux compris) `_` pour améliorer la lisibilité.

Les littéraux réels peuvent être de type :

- _float_ : avec un suffixe `f` ou `F`
- _double_ : sans suffixe ou avec un suffixe `d` ou `D`
- _decimal_ : avec un suffixe `m` ou `M`

Le code suivant illustre l'utilisation de ces suffixes :

```cs
var floatLiteral = 3_000.5f; // 3000.5 en float
floatLiteral = 3000.5F; // 3000.5 en float

var doubleLiteral = 3_000.5; // 3000.5 en double sans suffixe
doubleLiteral = 3_000.5d; // 3000.5 en double avec suffixe
doubleLiteral = 3000.5D; // 3000.5 en double avec suffixe

var decimalLiteral = 3_000.5m; // 3000.5 en decimal
decimalLiteral = 3000.5M; // 3000.5 en decimal
```

:::tip

Il est également possible d'utiliser la notation scientifique.

```cs
double d = 1.5e2; // 150

float f = 843.47E-4f; // 0.084347

decimal m = 7.9E6m; // 7900000
```

:::

### Conversions numériques

Les conversions implicites suivantes sont possibles :

| **De** | **Vers**                                                                                         |
| ------ | ------------------------------------------------------------------------------------------------ |
| sbyte  | `short`, `int`, `long`, `float`, `double`, `decimal`, `nint`                                     |
| byte   | `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, `decimal`, `nint`, `nuint` |
| short  | `int`, `long`, `float`, `double`, `decimal`, `nint`                                              |
| ushort | `int`, `uint`, `long`, `ulong`, `float`, `double`, `decimal`, `nint`, `nuint`                    |
| int    | `long`, `float`, `double`, `decimal`, `nint`                                                     |
| uint   | `long`, `ulong`, `float`, `double`, `decimal`, `nuint`                                           |
| long   | `float`, `double`, `decimal`                                                                     |
| ulong  | `float`, `double`, `decimal`                                                                     |
| float  | `double`                                                                                         |
| nint   | `long`, `float`, `double`, `decimal`                                                             |
| nuint  | `ulong`, `float`, `double`, `decimal`                                                            |

Les conversions explicites suivantes sont possibles :

| **De**  | **Vers**                                                                                                |
| ------- | ------------------------------------------------------------------------------------------------------- |
| sbyte   | `byte`, `ushort`, `uint`, `ulong`, `nuint`                                                              |
| byte    | `sbyte`                                                                                                 |
| short   | `sbyte`, `byte`, `ushort`, `uint`, `ulong`, `nuint`                                                     |
| ushort  | `sbyte`, `byte`, `short`                                                                                |
| int     | `sbyte`, `byte`, `short`, `ushort`, `uint`, `ulong`, `nuint`                                            |
| uint    | `sbyte`, `byte`, `short`, `ushort`, `int`, `nint`                                                       |
| long    | `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `ulong`, `nint`, `nuint`                             |
| ulong   | `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `nint`, `nuint`                              |
| float   | `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `decimal`, `nint`, `nuint`          |
| double  | `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `decimal`, `nint`, `nuint` |
| decimal | `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, `nint`, `nuint`  |
| nint    | `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `ulong`, `nuint`                                     |
| nuint   | `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `nint`                                       |

### Les autres primitifs

| **Type C# / Mot clé** | **Valeurs possibles**     | **Description**          | **Type .NET**  | **Valeur par défaut** |
| --------------------- | ------------------------- | ------------------------ | -------------- | --------------------- |
| `bool`                | true / false              | Type booléen             | System.Boolean | false                 |
| `char`                | U+0000 à U+FFFF (16 bits) | Type caractère           | System.Char    | \0                    |
| `string`              | Tous les caractères       | Type chaîne de caractère | System.String  | null                  |

#### Littéraux de caractères

Il est possible de spécifier une valeur `char` avec :

- un littéral de caractère
- une séquence d'échappement Unicode, qui est `\u` suivi de la représentation hexadécimale d'un code de caractère
- une séquence d'échappement héxadécimale, qui est `\x` suivi de la représentation hexadécimale d'un code de caractère

```cs
var charLiteral = 'a'; // a
charLiteral = '\u0061'; // a
charLiteral = '\x0061'; // a
```

### Autres types

#### Enumérations

Les énumérations sont des types de données qui permettent de définir un ensemble de constantes nommées du type entier.
Pour définir une énumération, on utilise le mot clé `enum` suivi du nom de l'énumération et de ses valeurs.

```cs
enum Couleur
{
    Rouge, // 0
    Vert, // 1
    Bleu // 2
}
```

Par défaut, les valeurs de l'énumération sont de type `int`, elles commencent à 0 et s'incrémentent de 1.

Il est possible de spécifier une valeur pour chaque élément de l'énumération.

```cs
enum Couleur
{
    Rouge = 10,
    Vert = 20,
    Bleu = 30
}
```

##### Enumérations comme indicateurs binaires

Si vous souhaitez qu'un type d'énumération représente une combinaison de choix, définissez ses valeurs comme des puissances de deux distinctes (1, 2, 4, 8, etc.). Chaque valeur représente un seul bit qui peut être activé ou désactivé. Il faut également lui appliquer l'attribut `Flags`.

Vous pourrez alors utiliser les opérateurs binaires pour combiner des choix ou croiser des combinaisons de choix.

```cs
[Flags]
public enum Days
{
   None = 0b_0000_0000,  // 0
   Monday = 0b_0000_0001,  // 1
   Tuesday = 0b_0000_0010,  // 2
   Wednesday = 0b_0000_0100,  // 4
   Thursday = 0b_0000_1000,  // 8
   Friday = 0b_0001_0000,  // 16
   Saturday = 0b_0010_0000,  // 32
   Sunday = 0b_0100_0000,  // 64
   Weekend = Saturday | Sunday
}

public class FlagsEnumExample
{
   public static void main()
   {
      Days meetingDays = Days.Monday | Days.Wednesday | Days.Friday;
      Console.WriteLine(meetingDays);
      // Output:
      // Monday, Wednesday, Friday

      Days workingFromHomeDays = Days.Thursday | Days.Friday;
      Console.WriteLine($"Join a meeting by phone on {meetingDays & workingFromHomeDays}");
      // Output:
      // Join a meeting by phone on Friday

      bool isMeetingOnTuesday = (meetingDays & Days.Tuesday) == Days.Tuesday;
      Console.WriteLine($"Is there a meeting on Tuesday: {isMeetingOnTuesday}");
      // Output:
      // Is there a meeting on Tuesday: False

      var a = (Days)37; // 37 = 32 + 4 + 1 = Saturday + Wednesday + Monday
      Console.WriteLine(a);
      // Output:
      // Monday, Wednesday, Saturday
   }
}
```

#### Les structures

Les structures sont des types de données qui permettent de définir un ensemble de champs.
Pour définir une structure, on utilise le mot clé `struct` suivi du nom de la structure et de ses champs.

```cs
struct Point
{
    public int X;
    public int Y;
}
```

Les structures sont des types de données qui sont passés par valeur et non par référence.

En règle générale, vous utilisez des types de structure pour concevoir de petits types centrés sur les données qui n'ont pas de comportement. Par exemple, les types de structure sont appropriés pour représenter des points dans un système de coordonnées ou des valeurs de pixels dans une image, mais pas pour représenter un employé dans une entreprise, car un employé a un comportement tel que le calcul de la rémunération. Envisagez plutôt d'utiliser une classe pour des données avec un comportement.

Si vous concevez un type de structure, considérez la possibilité de déclarer la structure comme `readonly` pour éviter que les membres de la structure ne soient modifiés après la création de la structure.

#### Les tuples

Les tuples sont des types de données qui permettent de regrouper plusieurs éléments de types différents.
Pour définir un tuple, on utilise des parenthèses `()` et on sépare les éléments par des virgules `,`.

```cs
(int, int) tuple1 = (1, 2);
Console.WriteLine($"Le tuple1 contient ${tuple1.Count} éléments et sa somme est {tuple1.Sum}");
// Output:
// Le tuple1 contient 2 éléments et sa somme est 3

(double, float, int) tuple2 = (1.5, 2.5f, 3);
Console.WriteLine($"Un tuple avec 3 éléments : ${tuple2.Item1}, ${tuple2.Item2}, ${tuple2.Item3}");
// Output:
// Un tuple avec 3 éléments : 1.5, 2.5, 3
```

Le cas d'usage le plus courant des tuples est de retourner plusieurs valeurs d'une méthode.

```cs
(int, int) GetMinMax(int[] array)
{
    int min = array[0];
    int max = array[0];

    for (int i = 1; i < array.Length; i++)
    {
        if (array[i] < min)
        {
            min = array[i];
        }
        else if (array[i] > max)
        {
            max = array[i];
        }
    }

    return (min, max);
}
```

## Les Opérateurs

#### Les opérateurs arithmétiques

| **Opérateur** | **Description** | **Exemple** |
| ------------- | --------------- | ----------- |
| **+**         | Addition        | 1 + 2 = 3   |
| **-**         | Soustraction    | 1 - 2 = -1  |
| **\***        | Multiplication  | 1 \* 2 = 2  |
| **/**         | Division        | 1 / 2 = 0   |
| **%**         | Modulo          | 1 % 2 = 1   |

#### Les opérateurs de comparaison

| **Opérateur** | **Description**   | **Exemple** |
| ------------- | ----------------- | ----------- |
| **==**        | Egal              | 1 == 2      |
| **!=**        | Différent         | 1 != 2      |
| **<**         | Inférieur         | 1 < 2       |
| **<=**        | Inférieur ou égal | 1 <= 2      |
| **>**         | Supérieur         | 1 > 2       |
| **>=**        | Supérieur ou égal | 1 >= 2      |

#### Les opérateurs logiques

| **Opérateur** | **Description** | **Exemple**        |
| ------------- | --------------- | ------------------ |
| **&&**        | ET              | 1 == 1 && 2 == 2   |
| **\|\|**      | OU              | 1 == 1 \|\| 2 == 2 |
| **!**         | NON             | !(1 == 1)          |

#### Les opérateurs d'incrémentation et de décrémentation

| **Opérateur** | **Description** | **Exemple** |
| ------------- | --------------- | ----------- |
| **++**        | Incrémentation  | a++         |
| **--**        | Décrémentation  | a--         |

#### Les opérateurs d'affectation

| **Opérateur** | **Description** | **Exemple** |
| ------------- | --------------- | ----------- |
| **=**         | Affectation     | a = 1       |
| **+=**        | Addition        | a += 1      |
| **-=**        | Soustraction    | a -= 1      |
| **\*=**       | Multiplication  | a \*= 1     |
| **/=**        | Division        | a /= 1      |
| **%=**        | Modulo          | a %= 1      |

#### Les opérateurs de décalage

| **Opérateur** | **Description**   | **Exemple** |
| ------------- | ----------------- | ----------- |
| **<<**        | Décalage à gauche | a << 1      |
| **>>**        | Décalage à droite | a >> 1      |

#### Les opérateurs binaires

| **Opérateur** | **Description**     | **Exemple** |
| ------------- | ------------------- | ----------- |
| **&**         | ET binaire          | a & b       |
| **\|**        | OU binaire          | a \| b      |
| **^**         | OU exclusif binaire | a ^ b       |
| **~**         | NON binaire         | ~a          |

#### Les opérateurs ternaires

| **Opérateur** | **Description** | **Exemple** |
| ------------- | --------------- | ----------- |
| **?:**        | Conditionnel    | a ? b : c   |

#### Les opérateurs de pointeur

| **Opérateur** | **Description** | **Exemple** |
| ------------- | --------------- | ----------- |
| **&**         | Adresse         | &a          |
| **\***        | Pointeur        | \*a         |

#### Les opérateurs de taille et de type

| **Opérateur** | **Description** | **Exemple** |
| ------------- | --------------- | ----------- |
| **sizeof**    | Taille          | sizeof(a)   |
| **typeof**    | Type            | typeof(a)   |

#### Les opérateurs de portée

| **Opérateur** | **Description** | **Exemple** |
| ------------- | --------------- | ----------- |
| **::**        | Portée          | a::b        |

#### Les opérateurs de membre

| **Opérateur** | **Description** | **Exemple** |
| ------------- | --------------- | ----------- |
| **.**         | Membre          | a.b         |
| **->**        | Pointeur membre | a->b        |

#### Les opérateurs de séquence

| **Opérateur** | **Description** | **Exemple** |
| ------------- | --------------- | ----------- |
| **,**         | Séquence        | a, b        |

#### Les opérateurs de pré/post incrémentation/décrémentation

| **Opérateur** | **Description**     | **Exemple** |
| ------------- | ------------------- | ----------- |
| **++**        | Pré-incrémentation  | ++a         |
| **--**        | Pré-décrémentation  | --a         |
| **++**        | Post-incrémentation | a++         |
| **--**        | Post-décrémentation | a--         |
